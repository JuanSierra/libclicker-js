	/*private Generator(World world) {
        super(world);
    }


    private Generator(World world, String name) {
        super(world, name);
    }
*/

function generator(){
	Item.call(this);
	this.itemLevel;
	this.maxItemLevel;
	this.modifiers;
	this.amountMultiplier;
	this.useRemainder;
	this.timesProcessed;
	this.remainder;
	
	//modifiable
	this.world;
	this.name;
	this.onProcessed;
	this.resource;
	this.baseAmount;
	this.amountMultiplier;
	this.maxLevel;//Long.MAX_VALUE;
	this.basePrice;
	this.priceMultiplier;
	this.probability;
	this.probabilitySet;
	this.useRemainde;
	this.cooldown;

	//Builder
	this.Builder = function(world) {
		self = this;
		self.itemLevel =0;
		self.maxItemLevel = 999999999;
		self.modifiers = [];
		self.amountMultiplier = 0;
		self.useRemainder = true;
		self.timesProcessed = 0;
		self.remainder = 0;
	
		//modifiable
		self.world = world;
		self.name = "Nameless generator";
		self.onProcessed = null;
		self.resource;
		self.baseAmount = 1;
		self.amountMultiplier = 1.1;
		self.maxLevel = 999999999;//Long.MAX_VALUE;
		self.basePrice = 1;
		self.priceMultiplier = 1.1;
		self.probability = 1.0;
		self.probabilitySet = false;
		self.useRemainder = true;
		self.cooldown = 0.0;

        /**
         * Creates a new generator builder
         *
         * @param world World to build the generator into
         */
        /*public Builder(World world) {
            this.world = world;
        }*/

        /**
         * Sets the cooldown of this generator (in seconds).
         * This is the minimum time between processing this
         * generator.
         *
         * @param cooldown in seconds
         * @return This builder for chaining
         */
        this.cooldown = function(cooldown) {
            self.cooldown = cooldown;
            return this;
        }

        /**
         * Store remainder of resources and generate an extra
         * when the remainder "overflows"
         *
         * @return This builder for chaining
         */
        this.useRemainder = function() {
            self.useRemainder = true;
            return this;
        }

        /**
         * Discard remainder of resources when generating.
         *
         * @return This builder for chaining
         */
        this.discardRemainder = function() {
            self.useRemainder = false;
            return this;
        }

        /**
         * Sets the name for the generator
         *
         * @param name Name for the generator
         * @return This builder for chaining
         */
        this.name = function(name) {
            self.name = name;
            return this;
        }

        /**
         * Sets the multiplier for resource generation. This multiplier
         * is used in the formula (amount) = (base amount) * (multiplier) ^ (level)
         *
         * @param multiplier Amount generation multiplier per level
         * @return This builder for chaining
         */
        this.multiplier = function(multiplier) {
            self.amountMultiplier = multiplier;
            return this;
        }

        /**
         * Sets the maximum allowed level for this generator. The max level must
         * be greated than zero.
         *
         * @param maxLevel Maximum allowed level for this generator
         * @return This builder for chaining
         */
        /*this.maxLevel = function(maxLevel) {
            //if (maxLevel <= 0)
            //    throw new IllegalArgumentException("Max level must be greater than 0");
            self.maxLevel = maxLevel;
            return this;
        }*/

        /**
         * Sets the base amount of resources generated by this generator.
         * This is the amount the generator generates at level 1 and is used
         * as the base for the higher levels.
         *
         * @param amount Base amount of resources generated at level 1
         * @return This builder for chaining
         */
        this.baseAmount=function(amount) {
            //if (amount == null) throw new IllegalArgumentException("Base amount cannot be null");
            self.baseAmount = amount;
            return this;
        }

        /**
         * Sets the currency that should be generated by the generator.
         *
         * @param resource Resource to generate
         * @return This builder for chaining
         * @throws IllegalArgumentException Thrown if the currency is null
         */
        this.generate = function(resource){ //throws IllegalArgumentException {
            //if (resource == null) throw new IllegalArgumentException("Currency cannot be null");
            self.resource = resource;
            return this;
        }

        /**
         * Sets a callback for the generator to be called when the generator
         * has finished its processing cycle (i.e. has generated something).
         *
         * @param callback Callback to call after generating something
         * @return This builder for chaining
         */
        this.callback = function(callback) {
            self.onProcessed = callback;
            return this;
        }

        this.price = function(price) {
            self.basePrice = price;
            return this;
        }

        this.priceMultiplier = function(multiplier) {
            self.priceMultiplier = multiplier;
            return this;
        }

        /**
         * Set a probability for this generator to "work" when it's processed
         *
         * @param probability Probability percentage (between 0.0 and 1.0)
         * @return This builder for chaining
         */
        this.probability = function(probability) {
            //if (probability < 0 || probability > 1.0)
            //    throw new IllegalArgumentException("Probability should be between 0.0 and 1.0");
            self.probability = probability;
            self.probabilitySet = true;
			
            return this;
        }

        /**
         * Constructs the generator based on the given parameters
         *
         * @return The generator
         */
        this.build = function() {
            var g = new generator(world, self.name);
			
			g.itemLevel = self.itemLevel;
			g.modifiers = self.modifiers;
			g.timesProcessed = self.timesProcessed;
			g.remainder = self.remainder;
			
            g.callback = self.onProcessed;
            g.resource = self.resource;
            g.amountMultiplier = self.amountMultiplier;
            g.baseAmount = self.baseAmount;
            g.maxItemLevel = self.maxLevel;
            g.basePrice = self.basePrice;
            g.priceMultiplier = self.priceMultiplier;
            g.probability = self.probability;
            g.useProbability = self.probabilitySet;
            g.useRemainder = self.useRemainder;
            g.cooldown = self.cooldown;
			g.world = self.world;
            g.world.addGenerator(g);
			
            return g;
        }
    }
	
	this.equals = function(a,b) {
		return JSON.stringify(a) === JSON.stringify(b);
	}
	
	/*this.itemLevel =0;
	this.maxItemLevel =0;
	this.modifiers = [];
	this.amountMultiplier = 0;
	this.useRemainder = true;
	this.timesProcessed = 0;
	this.remainder = 0;*/
	
	this.upgrade = function(){
		if (this.itemLevel < this.maxItemLevel) {
            this.itemLevel++;
        }
	}

    /**
     * Downgrades this generator by one level
     */
    this.downgrade = function() {
        if (this.itemLevel > 0) {
            this.itemLevel--;
        }
    }

    /**
     * Retrieves the amount this generator currently is generating per
     * processing cycle
     *
     * @return Amount of resources generated by this generator
     */
    this.getGeneratedAmount = function() {
        if (this.itemLevel == 0) return 0;

        var tmp = this.baseAmount;
        tmp = tmp * Math.pow(this.amountMultiplier, this.itemLevel - 1);
        if (this.useRemainder) {
			//if 1 divided in tmp
            //var tmpRem = tmp.remainder(BigDecimal.ONE).doubleValue();
			var tmpRem = 1/tmp;
            this.remainder += tmpRem;
            if (this.remainder >= 0.999) {
                this.remainder -= 1.0;
                tmp = tmp + 1;
            }
        }

        tmp = this.processModifiers(tmp);

        return tmp;
    }

    this.processModifiers = function(val) {
        if (this.modifiers.length == 0) return val;

        for (var m in this.modifiers) {
            var d = m.getMultiplier();
            if (d != 1.0) {
                val = val * d;
            }
        }

        return val;
    }

    /**
     * Determines if this generator should generate anything based on its
     * properties such as item level and probability.
     *
     * @return True if should work, false otherwise
     */
    this.isWorking = function() {
        if (this.itemLevel > 0) {
            if (!this.useProbability || Math.Random() < this.probability) return true;
        }
		
        return false;
    }

    /**
     * Processes this generator, generating resources as per the rules
     * of this generator.
     */
    this.process = function() {
        if (this.isWorking()) {
            this.resource.generate(this.getGeneratedAmount());
            this.timesProcessed++;
            //if (callback != null) callback.onProcessed();
        }
    }

    /**
     * Retrieves the number of times this generator has done its processing
     *
     * @return Number of times processed
     */
    this.getTimesProcessed = function() {
        return this.timesProcessed;
    }

    this.attachModifier = function(modifier) {
        if (modifier && !this.modifiers.contains(modifier)) {
            this.modifiers.push(modifier);
        }
    }

    this.detachModifier = function(modifier) {
        if (modifier) {
            this.modifiers.remove(modifier);
        }
    }
}

generator.prototype = Object.create(Item.prototype);
generator.prototype.constructor = generator;