/*
    private Generator(World world) {
        super(world);
    }


    private Generator(World world, String name) {
        super(world, name);
    }
*/

class Generator extends Item {
    contructor(){
        this.itemLevel;
        this.maxItemLevel;
        this.modifiers;
        this.amountMultiplier;
        this.useRemainder;
        this.timesProcessed;
        this.remainder;
        
        //modifiable
        this.world;
        this.name;
        this.onProcessed;
        this.resource;
        this.baseAmount;
        this.amountMultiplier;
        this.maxLevel;//Long.MAX_VALUE;
        this.basePrice;
        this.priceMultiplier;
        this.probability;
        this.probabilitySet;
        this.useRemainde;
        this.cooldown;
    }

	static get Builder() {
        class Builder {
           constructor(world) {
                this.itemLevel =0;
                this.maxItemLevel = 999999999;
                this.modifiers = [];
                this.amountMultiplier = 0;
                this.useRemainder = true;
                this.timesProcessed = 0;
                this.remainder = 0;
            
                //modifiable
                this.world = world;
                this.name = "Nameless generator";
                this.onProcessed = null;
                this.resource;
                this.baseAmount = 1;
                this.amountMultiplier = 1.1;
                this.maxLevel = 999999999;//Long.MAX_VALUE;
                this.basePrice = 1;
                this.priceMultiplier = 1.1;
                this.probability = 1.0;
                this.probabilitySet = false;
                this.useRemainder = true;
                this.cooldown = 0.0;
           }
            /**
             * Sets the cooldown of this generator (in seconds).
             * This is the minimum time between processing this
             * generator.
             *
             * @param cooldown in seconds
             * @return This builder for chaining
             */
            cooldown(cooldown) {
                this.cooldown = cooldown;
                return this;
            }

            /**
             * Store remainder of resources and generate an extra
             * when the remainder "overflows"
             *
             * @return This builder for chaining
             */
            useRemainder() {
                this.useRemainder = true;
                return this;
            }

            /**
             * Discard remainder of resources when generating.
             *
             * @return This builder for chaining
             */
            discardRemainder() {
                this.useRemainder = false;
                return this;
            }

            /**
             * Sets the name for the generator
             *
             * @param name Name for the generator
             * @return This builder for chaining
             */
            name(name) {
                this.name = name;
                return this;
            }

            /**
             * Sets the multiplier for resource generation. This multiplier
             * is used in the formula (amount) = (base amount) * (multiplier) ^ (level)
             *
             * @param multiplier Amount generation multiplier per level
             * @return This builder for chaining
             */
            multiplier(multiplier) {
                this.amountMultiplier = multiplier;
                return this;
            }

            /**
             * Sets the maximum allowed level for this generator. The max level must
             * be greated than zero.
             *
             * @param maxLevel Maximum allowed level for this generator
             * @return This builder for chaining
             */
            /*this.maxLevel = function(maxLevel) {
                //if (maxLevel <= 0)
                //    throw new IllegalArgumentException("Max level must be greater than 0");
                self.maxLevel = maxLevel;
                return this;
            }*/

            /**
             * Sets the base amount of resources generated by this generator.
             * This is the amount the generator generates at level 1 and is used
             * as the base for the higher levels.
             *
             * @param amount Base amount of resources generated at level 1
             * @return This builder for chaining
             */
            baseAmount(amount) {
                //if (amount == null) throw new IllegalArgumentException("Base amount cannot be null");
                this.baseAmount = amount;
                return this;
            }

            /**
             * Sets the currency that should be generated by the generator.
             *
             * @param resource Resource to generate
             * @return This builder for chaining
             * @throws IllegalArgumentException Thrown if the currency is null
             */
            generate(resource) { //throws IllegalArgumentException {
                //if (resource == null) throw new IllegalArgumentException("Currency cannot be null");
                this.resource = resource;
                return this;
            }

            /**
             * Sets a callback for the generator to be called when the generator
             * has finished its processing cycle (i.e. has generated something).
             *
             * @param callback Callback to call after generating something
             * @return This builder for chaining
             */
            callback(callback) {
                this.onProcessed = callback;
                return this;
            }

            price(price) {
                this.basePrice = price;
                return this;
            }

            priceMultiplier(multiplier) {
                this.priceMultiplier = multiplier;
                return this;
            }

            /**
             * Set a probability for this generator to "work" when it's processed
             *
             * @param probability Probability percentage (between 0.0 and 1.0)
             * @return This builder for chaining
             */
            probability(probability) {
                //if (probability < 0 || probability > 1.0)
                //    throw new IllegalArgumentException("Probability should be between 0.0 and 1.0");
                this.probability = probability;
                this.probabilitySet = true;
                
                return this;
            }

            build() {
                return new Generator(this);
            }
        }

        return Builder;
    }

	equals(a,b) {
		return JSON.stringify(a) === JSON.stringify(b);
	}
	
	/*this.itemLevel =0;
	this.maxItemLevel =0;
	this.modifiers = [];
	this.amountMultiplier = 0;
	this.useRemainder = true;
	this.timesProcessed = 0;
	this.remainder = 0;*/
	
	upgrade() {
		if (this.itemLevel < this.maxItemLevel) {
            this.itemLevel++;
        }
	}

    /**
     * Downgrades this generator by one level
     */
    downgrade() {
        if (this.itemLevel > 0) {
            this.itemLevel--;
        }
    }

    /**
     * Retrieves the amount this generator currently is generating per
     * processing cycle
     *
     * @return Amount of resources generated by this generator
     */
    getGeneratedAmount() {
        if (this.itemLevel == 0) return 0;

        var tmp = this.baseAmount;
        tmp = tmp * Math.pow(this.amountMultiplier, this.itemLevel - 1);
        if (this.useRemainder) {
			//if 1 divided in tmp
            //var tmpRem = tmp.remainder(BigDecimal.ONE).doubleValue();
			var tmpRem = 1/tmp;
            this.remainder += tmpRem;
            if (this.remainder >= 0.999) {
                this.remainder -= 1.0;
                tmp = tmp + 1;
            }
        }

        tmp = this.processModifiers(tmp);

        return tmp;
    }

    processModifiers(val) {
        if (this.modifiers.length == 0) return val;

        for (var m in this.modifiers) {
            var d = m.getMultiplier();
            if (d != 1.0) {
                val = val * d;
            }
        }

        return val;
    }

    /**
     * Determines if this generator should generate anything based on its
     * properties such as item level and probability.
     *
     * @return True if should work, false otherwise
     */
    isWorking() {
        if (this.itemLevel > 0) {
            if (!this.useProbability || Math.Random() < this.probability) return true;
        }
		
        return false;
    }

    /**
     * Processes this generator, generating resources as per the rules
     * of this generator.
     */
    process() {
        if (this.isWorking()) {
            this.resource.generate(this.getGeneratedAmount());
            this.timesProcessed++;
            //if (callback != null) callback.onProcessed();
        }
    }

    /**
     * Retrieves the number of times this generator has done its processing
     *
     * @return Number of times processed
     */
    getTimesProcessed() {
        return this.timesProcessed;
    }

    attachModifier(modifier) {
        if (modifier && !this.modifiers.contains(modifier)) {
            this.modifiers.push(modifier);
        }
    }

    detachModifier(modifier) {
        if (modifier) {
            this.modifiers.remove(modifier);
        }
    }
}

export default Generator;